#Встановлюємо необхідні пакети:
install.packages("TTR")
install.packages("forecast")
install.packages("corrgram")


#Лаб.робота 6

#1. Зчитати дані у формі часового ряду. Зобразити отриманий часовий ряд (з підписами).
#2. Провести згладжування ряду з різним кроком. 
#3. Розбити вихідний часовий ряд на систематичну, періодичну та хаотичну складові. 
#4. Побудувати корелограму ЧР.

#1.a : Зчитати дані у формі часового ряду.
birth <- scan("http://robjhyndman.com/tsdldata/data/nybirths.dat")
birth.ts <- ts(birth, start=c(1946,1), frequency = 12)
#1.b Зобразити отриманий часовий ряд (з підписами).
birth.ts
plot(birth.ts, xlab = "Час", ylab = "Народжуваність, тис. чол.",main="Основний графік") 
logbirth.ts<-log(birth.ts)
plot(logbirth.ts, xlab = "Час", ylab = "Народжуваність, тис. чол.",main="Логарифмований графік") 
#1.c Перевірка на часовий ряд
is.ts(birth.ts)

#2. Провести згладжування ряду з різним кроком. 
#a За допомогою скользящего середнього SMA

library("TTR")
#a.1 крок 3:
SMA3birth.ts<- SMA(birth.ts,n=3)
plot.ts(SMA3birth.ts,xlab = "Час", ylab = "Народжуваність, тис. чол.", main="Графік згладжений за кроком 3")
#a.2 крок 5:
SMA5birth.ts<- SMA(birth.ts,n=5)
plot.ts(SMA5birth.ts,xlab = "Час", ylab = "Народжуваність, тис. чол.", main="Графік згладжений за кроком 5")
#a.2 крок 8:
SMA8birth.ts<- SMA(birth.ts,n=8)
plot.ts(SMA8birth.ts,xlab = "Час", ylab = "Народжуваність, тис. чол.", main="Графік згладжений за кроком 8")
#a.2 крок 12:
SMA12birth.ts<- SMA(birth.ts,n=12)
plot.ts(SMA12birth.ts,xlab = "Час", ylab = "Народжуваність, тис. чол.", main="Графік згладжений за кроком 12")

#3. Розбити вихідний часовий ряд на систематичну, періодичну та хаотичну складові.
#Розклали часовий ряд
birthDecompose.ts <- decompose(birth.ts)
#Систематична
birthDecompose.ts$trend
#Перідична
birthDecompose.ts$seasonal
#Хаотична
birthDecompose.ts$random

#Виведемо графіки
plot(birthDecompose.ts)

#ПРОВЕДЕМО ОПТИМІЗАЦІЮ ТА ВИЛУЧИМО СЕЗОННІ ЯВИЩА
birthAdjusted.ts<- birth.ts- birthDecompose.ts$seasonal
plot(birthAdjusted.ts, main="без сезонних составляючих")

#4. Побудувати корелограму ЧР.

birthts.acf<- acf(birth.ts, lag.max = 36)
plot.acf <- function(ACFobj) {
  rr <- ACFobj$acf[-1]
  kk <- length(rr)
  nn <- ACFobj$n.used
  plot(seq(kk),rr,type="h",lwd=2,yaxs="i",xaxs="i",
       ylim=c(floor(min(rr)),1),xlim=c(0,kk+1),
       xlab="Lag",ylab="Correlation",las=1)
  abline(h=-1/nn+c(-2,2)/sqrt(nn),lty="dashed",col="blue")
  abline(h=0)
}
plot.acf(birthts.acf)

## length of ts
nn <- length(birth.ts)
## create straight line
tt <- seq(nn)
## set up plot area
par(mfrow=c(1,2))
## plot line
plot.ts(tt, ylab=expression(italic(x[t])), main="Time series plot of a straight line and the correlogram of its ACF")
## get ACF
line.acf <- acf(tt, plot=FALSE, main=" the correlogram of its ACF")
## plot ACF
plot.acf(line.acf)



#Лаб.робота 7

#1. Для часового ряду з попередньої роботи побудувати прогноз відповідним до моделі ЧР методом експоненційного згладжування (звичайним, подвійним чи потрійним – залежно від моделі) та методом ARIMA. 

#Simple Exponential Smoothing
birth.tsForecasts<- HoltWinters(birthAdjusted.ts,beta=FALSE,gamma=FALSE)
birth.tsForecasts$fitted
plot(birth.tsForecasts) #
birth.tsForecasts$SSE #sum-of-squared-error

#alpha близько до 1, що говорить про те, що прогноз базуэться на більш ранніх значеннях.

library("forecast")
help(forecast)

birth.tsForecasts2 <- forecast(birth.tsForecasts, h=90)
birth.tsForecasts2
par(mfrow=c(1,1))
plot(birth.tsForecasts2)

#Holt's Exponential Smoothing
birthHolt<- HoltWinters(birthAdjusted.ts,gamma=FALSE)
birthHolt
birthHolt$SSE
plot(birthHolt)
birthHolt2 <- forecast(birthHolt, h=90)
birthHolt2
plot(birthHolt2)
#Holt-Winters
birthHW<- HoltWinters(birthAdjusted.ts)
birthHW
birthHW$SSE
plot(birthHW)
birthHW2 <- forecast(birthHolt, h=90)
birthHW2
plot(birthHW2)
#2. Побудувати корелограми залишків. Оцінити (усно) якість прогнозу. 
#Simple
rr<-birth.tsForecasts2$residuals
plot(birth.tsForecasts2$residuals, ylab="residuals")
acf(rr, lag.max = 20,na.action = na.pass,main="Correlogram of Residuals")